// Code generated by "asm"; DO NOT EDIT.
package main

import (
	"log"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/asm"
	"github.com/cilium/ebpf/link"
	"github.com/miekg/bpf"

	//        "github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
)

var ctx = bpf.New()

var progSpec = &ebpf.ProgramSpec{
	Name:    "my_trace_prog",
	Type:    ebpf.TracePoint,
	License: "GPL",
}

func main() {
	setupRLimit()

	setupROMap()

	setupProg()

	prog, err := ebpf.NewProgram(progSpec)
	if err != nil {
		log.Fatalf("creating ebpf program: %s", err)
	}
	defer prog.Close()

	tp, err := link.Tracepoint("syscalls", "sys_enter_openat", prog, nil)
	if err != nil {
		log.Fatalf("opening tracepoint: %s", err)
	}
	defer tp.Close()
}

func setupROMap() {
	ctx.Map()
	ctx.ROdata.Put(0, "Hello world!\n")

}

func setupProg() {
	progSpec.Instructions = asm.Instructions{
		asm.Mov.Reg(asm.R6, asm.R1),

		asm.LoadMapPtr(asm.R1, ctx.FD()),
		asm.StoreImm(asm.RFP, -16, 0, asm.Word),
		asm.Mov.Reg(asm.R2, asm.RFP),
		asm.Add.Imm(asm.R2, -16),
		asm.FnMapLookupElem.Call(),

		asm.Mov.Reg(asm.R1, asm.R0),
		asm.FnTracePrintk.Call(),

		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}
}

func setupRLimit() {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}
}
